<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mapillary Image Fetcher</title>
  
  <!-- MapLibre GL JS CSS -->
  <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@4/dist/maplibre-gl.css" rel="stylesheet" />
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }
    
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
    
    /* 左上コントロールパネル */
    .control-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1;
      max-width: 340px;
    }
    
    .control-panel input[type="text"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 8px;
    }
    
    .control-panel button {
      width: 100%;
      padding: 10px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .control-panel button:hover:not(:disabled) {
      background: #0052a3;
    }
    
    .control-panel button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .control-panel button.secondary {
      background: #28a745;
    }
    
    .control-panel button.secondary:hover:not(:disabled) {
      background: #218838;
    }
    
    .control-panel button.clear {
      background: #6c757d;
    }
    
    .control-panel button.clear:hover {
      background: #5a6268;
    }
    
    .control-panel .hint {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
      line-height: 1.4;
    }
    
    .control-panel .status {
      padding: 8px;
      border-radius: 4px;
      font-size: 13px;
      margin-bottom: 8px;
      display: none;
    }
    
    .control-panel .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
      display: block;
    }
    
    .control-panel .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      display: block;
    }
    
    /* 右上ダウンロードコントロール */
    .download-control {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .download-control select {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      background: white;
    }
    
    .download-control select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .download-btn {
      background: #0066cc;
      color: white;
      padding: 8px 15px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }
    
    .download-btn:hover:not(:disabled) {
      background: #0052a3;
    }
    
    .download-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #ccc;
    }
    
    /* ローディングスピナー */
    .spinner-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.3);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column;
    }
    
    .spinner-overlay.active {
      display: flex;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #0066cc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    
    .spinner-overlay p {
      color: white;
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .spinner-overlay .progress {
      color: white;
      font-size: 14px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* トースト通知 */
    .toast {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s;
      max-width: 80%;
      text-align: center;
    }
    
    .toast.show {
      opacity: 1;
    }
    
    .toast.error {
      background: #d32f2f;
    }
    
    .toast.success {
      background: #388e3c;
    }
    
    /* ポップアップ画像スタイル */
    .maplibregl-popup-content {
      padding: 0;
      max-width: 400px;
    }
    
    .maplibregl-popup-content img {
      width: 100%;
      display: block;
      border-radius: 4px;
    }
    
    /* レスポンシブ対応 */
    @media (max-width: 480px) {
      .control-panel {
        max-width: calc(100% - 20px);
        font-size: 13px;
      }
      
      .download-control {
        font-size: 12px;
        flex-wrap: wrap;
      }
      
      .download-control select {
        font-size: 12px;
        padding: 6px 8px;
      }
      
      .download-btn {
        font-size: 12px;
        padding: 6px 12px;
      }
    }
  </style>
</head>
<body>
  <!-- 地図 -->
  <div id="map"></div>
  
  <!-- 左上コントロールパネル -->
  <div class="control-panel">
    <input 
      type="text" 
      id="tokenInput" 
      placeholder="Enter Mapillary Access Token"
      autocomplete="off"
    />
    <button id="verifyBtn">Verify Token</button>
    <div class="status" id="tokenStatus"></div>
    <button id="fetchBtn" class="secondary" disabled>Fetch Images in Current View</button>
    <button id="clearBtn" class="clear">Clear</button>
    <div class="hint">Pan/zoom the map to adjust the area, then click Fetch</div>
  </div>
  
  <!-- 右上ダウンロードコントロール -->
  <div class="download-control">
    <select id="formatSelect" disabled>
      <option value="geojson">GeoJSON</option>
      <option value="kml">KML</option>
      <option value="kmz">KMZ (with images)</option>
    </select>
    <button id="downloadBtn" class="download-btn" disabled>
      Download
    </button>
  </div>
  
  <!-- Loading Spinner -->
  <div class="spinner-overlay" id="spinnerOverlay">
    <div class="spinner"></div>
    <p id="loadingText">Loading...</p>
    <p class="progress" id="progressText"></p>
  </div>
  
  <!-- Toast Notification -->
  <div class="toast" id="toast"></div>
  
  <!-- MapLibre GL JS -->
  <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@4/dist/maplibre-gl.js"></script>
  <!-- JSZip for KMZ creation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <script>
    // Global variables
    let map;
    let geojsonData = null;
    let isTokenValid = false;
    
    // Initialize map
    function initMap() {
      map = new maplibregl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: {
            'osm': {
              type: 'raster',
              tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
              tileSize: 256,
              attribution: '© OpenStreetMap contributors'
            }
          },
          layers: [{
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 0,
            maxzoom: 19
          }]
        },
        center: [139.7671, 35.6812], // Tokyo
        zoom: 12
      });
      
      // Add Navigation Control
      map.addControl(new maplibregl.NavigationControl(), 'top-right');
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type} show`;
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }
    
    // Toggle loading display
    function setLoading(isLoading, text = 'Loading...', progress = '') {
      const overlay = document.getElementById('spinnerOverlay');
      const loadingText = document.getElementById('loadingText');
      const progressText = document.getElementById('progressText');
      loadingText.textContent = text;
      progressText.textContent = progress;
      
      if (isLoading) {
        overlay.classList.add('active');
      } else {
        overlay.classList.remove('active');
      }
    }
    
    // Verify token
    async function verifyToken() {
      const token = document.getElementById('tokenInput').value.trim();
      const statusDiv = document.getElementById('tokenStatus');
      const fetchBtn = document.getElementById('fetchBtn');
      
      if (!token) {
        statusDiv.className = 'status error';
        statusDiv.textContent = 'Please enter a token';
        isTokenValid = false;
        fetchBtn.disabled = true;
        return;
      }
      
      setLoading(true, 'Verifying token...');
      
      try {
        // Verify token by querying Mapillary API
        // Authorization: OAuth {token} header required
        // 0.01 deg x 0.01 deg = 0.0001 sq deg (much smaller than 0.010 sq deg limit)
        const response = await fetch(`https://graph.mapillary.com/images?bbox=139.76,35.68,139.77,35.69&limit=1&fields=id`, {
          headers: {
            'Authorization': `OAuth ${token}`
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          statusDiv.className = 'status success';
          statusDiv.textContent = '✓ Token is valid';
          isTokenValid = true;
          fetchBtn.disabled = false;
          showToast('Token is valid', 'success');
        } else {
          const errorData = await response.json();
          throw new Error(errorData.error?.message || `Authentication error (${response.status})`);
        }
      } catch (error) {
        console.error('Token verification error:', error);
        statusDiv.className = 'status error';
        statusDiv.textContent = '✗ Invalid token: ' + error.message;
        isTokenValid = false;
        fetchBtn.disabled = true;
        showToast('Invalid token', 'error');
      } finally {
        setLoading(false);
      }
    }
    
    // Get current map BBOX (with area limit check)
    function getCurrentBBox() {
      const bounds = map.getBounds();
      const west = bounds.getWest();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const north = bounds.getNorth();
      
      // Calculate BBOX area (square degrees)
      const width = east - west;
      const height = north - south;
      const area = width * height;
      
      // Mapillary limit is 0.010 square degrees
      // Use 0.009 square degrees (90%) as upper limit for safety
      const maxArea = 0.009;
      
      if (area > maxArea) {
        // If area is too large, shrink to fit within limit from center
        const centerLon = (west + east) / 2;
        const centerLat = (south + north) / 2;
        
        // Shrink as square (with safety margin)
        const halfSize = Math.sqrt(maxArea) / 2;
        
        return {
          bbox: `${centerLon - halfSize},${centerLat - halfSize},${centerLon + halfSize},${centerLat + halfSize}`,
          adjusted: true,
          originalArea: area,
          adjustedArea: maxArea
        };
      }
      
      return {
        bbox: `${west},${south},${east},${north}`,
        adjusted: false,
        area: area
      };
    }
    
    // Fetch Mapillary images (with pagination support)
    async function fetchMapillaryImages(bbox, accessToken) {
      const allFeatures = [];
      let url = `https://graph.mapillary.com/images?bbox=${bbox}&fields=id,computed_geometry,captured_at,compass_angle,thumb_2048_url&limit=2000`;
      let pageCount = 0;
      
      while (url) {
        pageCount++;
        setLoading(true, `Fetching data... (Page ${pageCount})`);
        
        const response = await fetch(url, {
          headers: {
            'Authorization': `OAuth ${accessToken}`
          }
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error?.message || `API Error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Convert to GeoJSON Feature
        if (data.data && data.data.length > 0) {
          data.data.forEach(item => {
            if (item.computed_geometry) {
              allFeatures.push({
                type: 'Feature',
                geometry: {
                  type: 'Point',
                  coordinates: item.computed_geometry.coordinates
                },
                properties: {
                  id: item.id,
                  captured_at: item.captured_at,
                  thumb_2048_url: item.thumb_2048_url,
                  compass_angle: item.compass_angle
                }
              });
            }
          });
        }
        
        // Check if there's a next page
        url = data.paging && data.paging.next ? data.paging.next : null;
      }
      
      return {
        type: 'FeatureCollection',
        features: allFeatures
      };
    }
    
    // Display points on map
    function displayPointsOnMap(geojson) {
      // Remove existing layer and source
      if (map.getLayer('mapillary-points')) {
        map.removeLayer('mapillary-points');
      }
      if (map.getSource('mapillary')) {
        map.removeSource('mapillary');
      }
      
      // Add new source and layer
      map.addSource('mapillary', {
        type: 'geojson',
        data: geojson
      });
      
      map.addLayer({
        id: 'mapillary-points',
        type: 'circle',
        source: 'mapillary',
        paint: {
          'circle-radius': 5,
          'circle-color': '#0066cc',
          'circle-stroke-width': 1,
          'circle-stroke-color': '#ffffff'
        }
      });
      
      // Click event: Show image in popup
      map.on('click', 'mapillary-points', (e) => {
        const feature = e.features[0];
        const props = feature.properties;
        const coords = feature.geometry.coordinates;
        
        const html = `
          <div>
            <img src="${props.thumb_2048_url}" alt="Mapillary Image" style="max-width: 100%;" />
            <p style="padding: 8px; margin: 0; font-size: 12px;">
              <strong>ID:</strong> ${props.id}<br>
              <strong>Captured:</strong> ${new Date(props.captured_at).toLocaleString()}
            </p>
          </div>
        `;
        
        new maplibregl.Popup()
          .setLngLat(coords)
          .setHTML(html)
          .addTo(map);
      });
      
      // Change cursor on hover
      map.on('mouseenter', 'mapillary-points', () => {
        map.getCanvas().style.cursor = 'pointer';
      });
      
      map.on('mouseleave', 'mapillary-points', () => {
        map.getCanvas().style.cursor = '';
      });
    }
    
    // Download GeoJSON
    function downloadGeoJSON() {
      if (!geojsonData) return;
      
      const dataStr = JSON.stringify(geojsonData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const filename = `mapillary_images_${timestamp}.geojson`;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      
      URL.revokeObjectURL(url);
      showToast('GeoJSON downloaded', 'success');
    }
    
    // Convert GeoJSON to KML
    function geojsonToKML(geojson) {
      let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Mapillary Images</name>
    <description>Street-level imagery locations from Mapillary</description>
    <Style id="mapillary-icon">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/blu-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
`;
      
      geojson.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        const props = feature.properties;
        const capturedDate = new Date(props.captured_at).toLocaleString();
        
        kml += `    <Placemark>
      <name>Image ${props.id}</name>
      <description><![CDATA[
        <strong>ID:</strong> ${props.id}<br>
        <strong>Captured:</strong> ${capturedDate}<br>
        <strong>Compass Angle:</strong> ${props.compass_angle}°<br>
        <a href="${props.thumb_2048_url}" target="_blank">View Image</a>
      ]]></description>
      <styleUrl>#mapillary-icon</styleUrl>
      <Point>
        <coordinates>${coords[0]},${coords[1]},0</coordinates>
      </Point>
    </Placemark>
`;
      });
      
      kml += `  </Document>
</kml>`;
      
      return kml;
    }
    
    // Download KML
    function downloadKML() {
      if (!geojsonData) return;
      
      const kmlStr = geojsonToKML(geojsonData, false);
      const blob = new Blob([kmlStr], { type: 'application/vnd.google-earth.kml+xml' });
      const url = URL.createObjectURL(blob);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const filename = `mapillary_images_${timestamp}.kml`;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      
      URL.revokeObjectURL(url);
      showToast('KML downloaded', 'success');
    }
    
    // Fetch image as blob with retry
    async function fetchImageAsBlob(url, retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          return await response.blob();
        } catch (error) {
          if (i === retries - 1) throw error;
          // Wait before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
        }
      }
    }
    
    // Download images in batches to avoid connection limits
    async function downloadImagesInBatches(features, imagesFolder, batchSize = 5) {
      const totalImages = features.length;
      let downloadedCount = 0;
      let failedCount = 0;
      
      for (let i = 0; i < features.length; i += batchSize) {
        const batch = features.slice(i, Math.min(i + batchSize, features.length));
        
        await Promise.all(
          batch.map(async (feature, batchIndex) => {
            const globalIndex = i + batchIndex;
            const imageUrl = feature.properties.thumb_2048_url;
            
            try {
              const imageBlob = await fetchImageAsBlob(imageUrl);
              imagesFolder.file(`image_${globalIndex}.jpg`, imageBlob);
              downloadedCount++;
            } catch (error) {
              console.error(`Failed to download image ${globalIndex}:`, error);
              failedCount++;
            }
            
            const progress = Math.round((downloadedCount + failedCount) / totalImages * 100);
            setLoading(true, 'Downloading images...', `${downloadedCount}/${totalImages} (${progress}%)`);
          })
        );
        
        // Small delay between batches
        if (i + batchSize < features.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      return { downloadedCount, failedCount };
    }
    
    // Download KMZ with embedded images
    async function downloadKMZ() {
      if (!geojsonData) return;
      
      try {
        setLoading(true, 'Creating KMZ...', '0%');
        
        const zip = new JSZip();
        const imagesFolder = zip.folder('images');
        
        // Generate KML with local image references
        const kmlStr = geojsonToKML(geojsonData, true);
        zip.file('doc.kml', kmlStr);
        
        // Download all images in batches
        const { downloadedCount, failedCount } = await downloadImagesInBatches(
          geojsonData.features,
          imagesFolder
        );
        
        setLoading(true, 'Compressing KMZ...', '');
        
        // Generate KMZ file
        const kmzBlob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(kmzBlob);
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `mapillary_images_${timestamp}.kmz`;
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        
        URL.revokeObjectURL(url);
        
        if (failedCount > 0) {
          showToast(`KMZ downloaded: ${downloadedCount} images (${failedCount} failed)`, 'success');
        } else {
          showToast(`KMZ downloaded with ${downloadedCount} images`, 'success');
        }
      } catch (error) {
        console.error('KMZ creation error:', error);
        showToast(`Error creating KMZ: ${error.message}`, 'error');
      } finally {
        setLoading(false);
      }
    }
    
    // Download based on selected format
    function handleDownload() {
      const format = document.getElementById('formatSelect').value;
      
      if (format === 'geojson') {
        downloadGeoJSON();
      } else if (format === 'kml') {
        downloadKML();
      } else if (format === 'kmz') {
        downloadKMZ();
      }
    }
    
    // Fetch button click event
    async function handleFetchClick() {
      const token = document.getElementById('tokenInput').value.trim();
      
      if (!isTokenValid) {
        showToast('Please verify token first', 'error');
        return;
      }
      
      // Get current map view BBOX (with area limit check)
      const bboxResult = getCurrentBBox();
      
      // Warn if area was adjusted
      if (bboxResult.adjusted) {
        showToast(`Area too large, auto-adjusted (${bboxResult.originalArea.toFixed(4)}→${bboxResult.adjustedArea.toFixed(4)} sq deg)`, 'info');
      }
      
      // Start fetching data
      setLoading(true, 'Fetching data...');
      
      try {
        const geojson = await fetchMapillaryImages(bboxResult.bbox, token);
        
        if (geojson.features.length === 0) {
          showToast('No Mapillary images found in this area', 'error');
        } else {
          geojsonData = geojson;
          displayPointsOnMap(geojson);
          document.getElementById('downloadBtn').disabled = false;
          document.getElementById('formatSelect').disabled = false;
          showToast(`${geojson.features.length} images fetched`, 'success');
        }
      } catch (error) {
        console.error('Error:', error);
        showToast(`Error: ${error.message}`, 'error');
      } finally {
        setLoading(false);
      }
    }
    
    // Clear button click event
    function handleClearClick() {
      // Clear Mapillary points
      if (map.getLayer('mapillary-points')) {
        map.removeLayer('mapillary-points');
      }
      if (map.getSource('mapillary')) {
        map.removeSource('mapillary');
      }
      
      geojsonData = null;
      document.getElementById('downloadBtn').disabled = true;
      document.getElementById('formatSelect').disabled = true;
      
      showToast('Cleared', 'info');
    }
    
    // Event listeners
    document.getElementById('verifyBtn').addEventListener('click', verifyToken);
    document.getElementById('fetchBtn').addEventListener('click', handleFetchClick);
    document.getElementById('clearBtn').addEventListener('click', handleClearClick);
    document.getElementById('downloadBtn').addEventListener('click', handleDownload);
    
    // Verify token on Enter key press
    document.getElementById('tokenInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        verifyToken();
      }
    });
    
    // Initialize map
    initMap();
  </script>
</body>
</html>